'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2017 - present, Botfuel (https://www.botfuel.io).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Fs = require('fs');
var util = require('util');
var fsExtra = require('fs-extra');
var Natural = require('natural');
var logger = require('logtown')('Classifier');

var _require = require('./config'),
    getConfiguration = _require.getConfiguration;

var fsStat = util.promisify(Fs.stat);

var INTENT_SUFFIX = '.intent';

/**
 * Classifier
 */

var Classifier = function () {
  /**
   * @constructor
   * @param {Object} config - the bot config
   */
  function Classifier(config) {
    _classCallCheck(this, Classifier);

    this.config = getConfiguration(config);
    logger.debug('constructor', config);
    this.modelFilename = this.config.path + '/models/model.json';
    this.intentDirname = this.config.path + '/src/intents';
    this.classifier = null;
    this.getStemmer().attach();
  }

  /**
   * Get classifier stemmer for it's locale
   * @returns {*|Stemmer} - the stemmer
   */


  _createClass(Classifier, [{
    key: 'getStemmer',
    value: function getStemmer() {
      switch (this.config.locale) {
        case 'fr':
          return Natural.PorterStemmerFr;
        case 'es':
          return Natural.PorterStemmerEs;
        case 'en':
        default:
          return Natural.PorterStemmer;
      }
    }

    /**
     * Init the classifier
     * @async
     * @returns {Promise.<void|Error>}
     */

  }, {
    key: 'init',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var intentsAndModelExist, isModelUpToDate;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                logger.debug('init');
                _context.next = 3;
                return this.intentsAndModelExist(this.modelFilename, this.intentDirname);

              case 3:
                intentsAndModelExist = _context.sent;

                if (intentsAndModelExist) {
                  _context.next = 7;
                  break;
                }

                logger.warn('No intents directory or model file');
                return _context.abrupt('return', null);

              case 7:
                _context.next = 9;
                return this.isModelUpToDate(this.modelFilename, this.intentDirname);

              case 9:
                isModelUpToDate = _context.sent;

                if (!isModelUpToDate) {
                  logger.warn('Your model is not up-to-date.');
                  logger.warn('Train it by running: ./node_modules/.bin/botfuel-train <CONFIG_FILE>');
                }
                return _context.abrupt('return', new Promise(function (resolve, reject) {
                  Natural.LogisticRegressionClassifier.load(_this.modelFilename, null, function (err, classifier) {
                    if (err !== null) {
                      return reject(err);
                    }
                    _this.classifier = classifier;
                    return resolve();
                  });
                }));

              case 12:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _ref.apply(this, arguments);
      }

      return init;
    }()

    /**
     * Checks if the model is up-to-date: is the model fresher than the intents?
     * @param {String} modelFilePath - the model file path
     * @param {String} intentsDirPath - the intents dir path
     * @returns {Boolean} true if the model is uptodate, false if not
     */

  }, {
    key: 'isModelUpToDate',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(modelFilePath, intentsDirPath) {
        var intentFiles, filteredIntents, _ref3, _ref4, modelLastModifiedTime, fileStats;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                logger.debug('isModelUpToDate');
                intentFiles = Fs.readdirSync(intentsDirPath, 'utf8');
                filteredIntents = intentFiles.filter(function (file) {
                  return file.substr(-INTENT_SUFFIX.length) === INTENT_SUFFIX;
                });
                _context2.next = 5;
                return Promise.all([fsStat(modelFilePath)].concat(_toConsumableArray(filteredIntents.map(function (intentFile) {
                  return fsStat(intentsDirPath + '/' + intentFile);
                }))));

              case 5:
                _ref3 = _context2.sent;
                _ref4 = _toArray(_ref3);
                modelLastModifiedTime = _ref4[0].mtimeMs;
                fileStats = _ref4.slice(1);
                return _context2.abrupt('return', fileStats.map(function (file) {
                  return file.mtimeMs;
                }).every(function (timestamp) {
                  return timestamp < modelLastModifiedTime;
                }));

              case 10:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function isModelUpToDate(_x, _x2) {
        return _ref2.apply(this, arguments);
      }

      return isModelUpToDate;
    }()

    /**
     * Checks the model file and intents directory exist
     * @param {String} modelFilePath - the model file path
     * @param {String} intentsDirPath - the intents dir path
     * @returns {Boolean} true if the model file and intents directory exist, false if not
     */

  }, {
    key: 'intentsAndModelExist',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(modelFilePath, intentsDirPath) {
        var _ref6, _ref7, intentDirExists, modelFileExists;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                logger.debug('intentsAndModelExist');
                _context3.next = 3;
                return Promise.all([fsExtra.pathExists(intentsDirPath), fsExtra.pathExists(modelFilePath)]);

              case 3:
                _ref6 = _context3.sent;
                _ref7 = _slicedToArray(_ref6, 2);
                intentDirExists = _ref7[0];
                modelFileExists = _ref7[1];
                return _context3.abrupt('return', intentDirExists && modelFileExists);

              case 8:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function intentsAndModelExist(_x3, _x4) {
        return _ref5.apply(this, arguments);
      }

      return intentsAndModelExist;
    }()

    /**
     * Compute features for a sentence
     * @param {String} sentence - the sentence
     * @returns {String[]} the tokenized and stemmed sentence
     */

  }, {
    key: 'computeFeatures',
    value: function computeFeatures(sentence) {
      return sentence.tokenizeAndStem();
    }

    /**
     * Classifies a sentence.
     * @param {String} sentence - the sentence
     * @param {Object[]} entities - the entities
     * @returns {Promise.<*>} a promise with entities and intents
     */

  }, {
    key: 'compute',
    value: function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(sentence, entities) {
        var features;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                logger.debug('compute', sentence, entities);
                // The bot has no intent

                if (this.classifier) {
                  _context4.next = 3;
                  break;
                }

                return _context4.abrupt('return', []);

              case 3:
                features = this.computeFeatures(sentence, entities);
                return _context4.abrupt('return', this.classifier.getClassifications(features).map(function (intent) {
                  return {
                    name: intent.label,
                    value: intent.value
                  };
                }));

              case 5:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function compute(_x5, _x6) {
        return _ref8.apply(this, arguments);
      }

      return compute;
    }()

    /**
     * Train bot model
     * @returns {Promise.<void>}
     */

  }, {
    key: 'train',
    value: function () {
      var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                logger.debug('train');
                // Make sure model file exists
                _context5.next = 3;
                return fsExtra.ensureFile(this.modelFilename);

              case 3:
                this.classifier = new Natural.LogisticRegressionClassifier(this.getStemmer());
                Fs.readdirSync(this.intentDirname, 'utf8').filter(function (fileName) {
                  return fileName.substr(-INTENT_SUFFIX.length) === INTENT_SUFFIX;
                }).map(function (fileName) {
                  logger.debug('train: filename', fileName);
                  var intent = fileName.substring(0, fileName.length - INTENT_SUFFIX.length);
                  logger.debug('train: intent', intent);
                  return Fs.readFileSync(_this2.intentDirname + '/' + fileName, 'utf8').toString().split('\n').map(function (line) {
                    logger.debug('train: line', line);
                    var features = _this2.computeFeatures(line, null); // TODO: compute also entities
                    logger.debug('train: features', features);
                    return _this2.classifier.addDocument(features, intent);
                  });
                });
                logger.debug('train: training');
                this.classifier.train();
                logger.debug('train: trained');
                this.classifier.save(this.modelFilename);
                logger.debug('train: saved');

              case 10:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function train() {
        return _ref9.apply(this, arguments);
      }

      return train;
    }()
  }]);

  return Classifier;
}();

module.exports = Classifier;