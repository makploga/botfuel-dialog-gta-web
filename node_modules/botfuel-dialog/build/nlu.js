'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2017 - present, Botfuel (https://www.botfuel.io).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var fs = require('fs');
var fsExtra = require('fs-extra');
var dir = require('node-dir');
var Qna = require('botfuel-qna-sdk');
var Spellchecking = require('botfuel-nlp-sdk').Spellchecking;
var logger = require('logtown')('Nlu');
var AuthenticationError = require('./errors/authentication-error');
var Classifier = require('./classifier');
var BooleanExtractor = require('./extractors/boolean-extractor');
var CompositeExtractor = require('./extractors/composite-extractor');

/**
 * A nlu module (could be replaced by an external one).
 */

var Nlu = function () {
  /**
   * @constructor
   * @param {Object} config - the bot config
   */
  function Nlu(config) {
    var _this = this;

    _classCallCheck(this, Nlu);

    logger.debug('constructor', config);
    this.config = config;
    this.extractor = null;
    this.qna = null;
    this.spellchecking = null;
    this.classifier = null;
    this.intentFilter = function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(intents) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt('return', intents.filter(function (intent) {
                  return intent.value > config.intentThreshold;
                }).map(function (intent) {
                  return intent.name;
                }));

              case 1:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
    var intentFilterPath = this.config.path + '/src/intent-filter.js';
    if (fsExtra.pathExistsSync(intentFilterPath)) {
      this.intentFilter = require(intentFilterPath);
    }
  }

  /**
   * Gets extractor files.
   * @param {String} path - extractors path
   * @returns {Array.<string>} - extractor files
   */


  _createClass(Nlu, [{
    key: 'getExtractorFiles',
    value: function getExtractorFiles(path) {
      var files = [];
      if (fs.existsSync(path)) {
        files = dir.files(path, { sync: true }) || files;
      }
      return files.filter(function (file) {
        return file.match(/^.*.js$/);
      });
    }

    /**
     * Gets extractors.
     * @param {String} path - extractors path
     * @returns {Array.<*>} - extractor instances
     */

  }, {
    key: 'getExtractors',
    value: function getExtractors(path) {
      // user extractors
      var extractors = this.getExtractorFiles(path).map(function (file) {
        var ExtractorConstructor = require(file);
        return new ExtractorConstructor(ExtractorConstructor.params);
      });
      // system extractors
      extractors.push(new BooleanExtractor({ locale: this.config.locale }));
      return extractors;
    }

    /**
     * Initializes the Nlu module.
     * @returns {Promise.<void>}
     */

  }, {
    key: 'init',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                logger.debug('init');
                // Extractors
                this.extractor = new CompositeExtractor({
                  extractors: this.getExtractors(this.config.path + '/src/extractors')
                });
                // Classifier
                this.classifier = new Classifier(this.config);
                _context2.next = 5;
                return this.classifier.init();

              case 5:
                // QnA
                if (this.config.qna) {
                  if (!process.env.BOTFUEL_APP_ID || !process.env.BOTFUEL_APP_KEY) {
                    logger.error('BOTFUEL_APP_ID and BOTFUEL_APP_KEY are required for using the QnA service!');
                  }
                  this.qna = new Qna({
                    appId: process.env.BOTFUEL_APP_ID,
                    appKey: process.env.BOTFUEL_APP_KEY
                  });
                }
                // Spellchecking
                if (this.config.spellchecking) {
                  if (!process.env.BOTFUEL_APP_ID || !process.env.BOTFUEL_APP_KEY) {
                    logger.error('BOTFUEL_APP_ID and BOTFUEL_APP_KEY are required for using the spellchecking service!');
                  }
                  this.spellchecking = new Spellchecking({
                    appId: process.env.BOTFUEL_APP_ID,
                    appKey: process.env.BOTFUEL_APP_KEY
                  });
                }

              case 7:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function init() {
        return _ref2.apply(this, arguments);
      }

      return init;
    }()

    /**
     * Computes intents and entities.
     * @param {String} sentence - the sentence
     * @param {Object} [context] - an optional context (brain and userMessage)
     * @returns {Promise} a promise with entities and intents
     */

  }, {
    key: 'compute',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(sentence, context) {
        var _qnaResult, classifierResult, qnaResult;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                logger.debug('compute', sentence);

                if (!this.config.spellchecking) {
                  _context3.next = 6;
                  break;
                }

                logger.debug('compute: spellchecking');
                _context3.next = 5;
                return this.spellcheck(sentence, this.config.spellchecking);

              case 5:
                sentence = _context3.sent.correctSentence;

              case 6:
                if (!this.config.qna) {
                  _context3.next = 26;
                  break;
                }

                logger.debug('compute: qna', this.config.qna);

                if (!(this.config.qna.when === 'before')) {
                  _context3.next = 15;
                  break;
                }

                _context3.next = 11;
                return this.computeWithQna(sentence);

              case 11:
                _qnaResult = _context3.sent;

                if (!(_qnaResult.intents.length > 0)) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt('return', _qnaResult);

              case 14:
                return _context3.abrupt('return', this.computeWithClassifier(sentence, context));

              case 15:
                _context3.next = 17;
                return this.computeWithClassifier(sentence, context);

              case 17:
                classifierResult = _context3.sent;

                if (!(classifierResult.intents.length > 0)) {
                  _context3.next = 20;
                  break;
                }

                return _context3.abrupt('return', classifierResult);

              case 20:
                _context3.next = 22;
                return this.computeWithQna(sentence);

              case 22:
                qnaResult = _context3.sent;

                if (!(qnaResult.intents.length > 0)) {
                  _context3.next = 25;
                  break;
                }

                return _context3.abrupt('return', qnaResult);

              case 25:
                return _context3.abrupt('return', {
                  intents: [],
                  entities: classifierResult.entities
                });

              case 26:
                return _context3.abrupt('return', this.computeWithClassifier(sentence, context));

              case 27:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function compute(_x2, _x3) {
        return _ref3.apply(this, arguments);
      }

      return compute;
    }()

    /**
     * Computes intents and entities using QnA.
     * @param {String} sentence - the user sentence
     * @returns {Promise.<Object>}
     */

  }, {
    key: 'computeWithQna',
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(sentence) {
        var qnas, strict;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                logger.debug('computeWithQna', sentence);
                _context4.prev = 1;
                _context4.next = 4;
                return this.qna.getMatchingQnas({ sentence: sentence });

              case 4:
                qnas = _context4.sent;

                logger.debug('computeWithQna: qnas', qnas);
                strict = this.config.qna.strict;

                if (!(strict && qnas.length === 1 || !strict && qnas.length > 0)) {
                  _context4.next = 9;
                  break;
                }

                return _context4.abrupt('return', {
                  intents: ['qnas'],
                  entities: [{
                    dim: 'qnas',
                    value: qnas
                  }]
                });

              case 9:
                return _context4.abrupt('return', {
                  intents: []
                });

              case 12:
                _context4.prev = 12;
                _context4.t0 = _context4['catch'](1);

                logger.error('Could not classify with QnA!');

                if (!(_context4.t0.statusCode === 403)) {
                  _context4.next = 17;
                  break;
                }

                throw new AuthenticationError();

              case 17:
                throw _context4.t0;

              case 18:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 12]]);
      }));

      function computeWithQna(_x4) {
        return _ref4.apply(this, arguments);
      }

      return computeWithQna;
    }()

    /**
     * Computes intents and entities using the classifier.
     * @param {String} sentence - the user sentence
     * @param {Object} [context] - an optional context (brain and userMessage)
     * @returns {Promise.<Object>}
     */

  }, {
    key: 'computeWithClassifier',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(sentence, context) {
        var entities, intents;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                logger.debug('computeWithClassifier', sentence);
                _context5.next = 3;
                return this.extractor.compute(sentence);

              case 3:
                entities = _context5.sent;

                logger.debug('computeWithClassifier: entities', entities);
                _context5.next = 7;
                return this.classifier.compute(sentence, entities);

              case 7:
                intents = _context5.sent;
                _context5.next = 10;
                return this.intentFilter(intents, context);

              case 10:
                intents = _context5.sent;

                intents = intents.slice(0, this.config.multiIntent ? 2 : 1);
                logger.debug('computeWithClassifier: intents', intents);
                return _context5.abrupt('return', {
                  intents: intents,
                  entities: entities
                });

              case 14:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function computeWithClassifier(_x5, _x6) {
        return _ref5.apply(this, arguments);
      }

      return computeWithClassifier;
    }()

    /**
     * Spellchecks a sentence.
     * @param {String} sentence - a sentence
     * @param {String} key - a dictionary key
     * @returns {Object} the spellchecking result
     */

  }, {
    key: 'spellcheck',
    value: function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(sentence, key) {
        var result;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;

                logger.debug('spellcheck', sentence, key);
                _context6.next = 4;
                return this.spellchecking.compute({ sentence: sentence, key: key });

              case 4:
                result = _context6.sent;

                logger.debug('spellcheck: result', result);
                return _context6.abrupt('return', result);

              case 9:
                _context6.prev = 9;
                _context6.t0 = _context6['catch'](0);

                logger.error('Could not spellcheck!');

                if (!(_context6.t0.statusCode === 403)) {
                  _context6.next = 14;
                  break;
                }

                throw new AuthenticationError();

              case 14:
                throw _context6.t0;

              case 15:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 9]]);
      }));

      function spellcheck(_x7, _x8) {
        return _ref6.apply(this, arguments);
      }

      return spellcheck;
    }()
  }]);

  return Nlu;
}();

module.exports = Nlu;