'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 - present, Botfuel (https://www.botfuel.io).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var omit = require('lodash/omit');
var logger = require('logtown')('PromptDialog');

var _require = require('../utils/entities'),
    filterIntersectingEntities = _require.filterIntersectingEntities,
    getEntityInitialValue = _require.getEntityInitialValue;

var Dialog = require('./dialog');

/**
 * The prompt dialog prompts the user for a number of entities.
 * The dialog parameters is an Object containing:
 *   - a namespace String representing the name of the dialog
 *   - an entities Object of the form:
 * ```
 *     <entity name>: {
 *         dim: String,
 *         priority: entities parameters will be matched with potential raw entities
 *             in order or priority (highest first)
 *         isFulfilled: Function returning a boolean that determines
 *             when to stop (true) or continue (false)
 *         reducer: Function that determines what to do each time a raw entity
 *             matches with an entity parameter: replace the previously matched entity, append it...
 *     }
 * ```
 * @extends Dialog
 */

var PromptDialog = function (_Dialog) {
  _inherits(PromptDialog, _Dialog);

  /**
   * @constructor
   * @param {Object} config - the bot config
   * @param {class} brain - the bot brain
   * @param {Object} parameters - the dialog parameters,
   * parameters.entities is a map mapping entities to optional parameters
   */
  function PromptDialog(config, brain, parameters) {
    _classCallCheck(this, PromptDialog);

    return _possibleConstructorReturn(this, (PromptDialog.__proto__ || Object.getPrototypeOf(PromptDialog)).call(this, config, brain, { reentrant: true }, parameters));
  }

  /**
   * Attempt to match an entity parameter with raw entities candidates extracted from a message.
   * We apply the reducer function to a raw entity candidate until we run out of candidates or
   * if the isFulfilled condition is met.
   * @param {Object} parameter - entity parameter we want to match with one or more raw entities
   * @param {Array<Object>} candidates - array of raw entities extracted
   * from a message: {
   *     dim: String,
   *     body: String,
   *     start: Number,
   *     end: Number,
   *     values: Array<Object>
   * }
   * @param {Object} initialValue - initial value of the entity we want to match
   * @returns {Object} object containing
   * remainingCandidates (candidates minus candidates used) and
   * newValue (value we matched with the parameter)
   */


  _createClass(PromptDialog, [{
    key: 'matchParameterWithCandidates',
    value: function matchParameterWithCandidates(_ref) {
      var dialogParameter = _ref.dialogParameter,
          _ref$candidates = _ref.candidates,
          candidates = _ref$candidates === undefined ? [] : _ref$candidates,
          initialValue = _ref.initialValue;

      var sameDimCandidates = candidates.filter(function (candidate) {
        return candidate.dim === dialogParameter.dim;
      });
      // Check if the parameter is already fulfilled with its initial value
      // If so, we replace the fulfilled parameterâ€™s entity
      // with the first candidate of the same dimension
      var replaceFulfilledEntity = dialogParameter.isFulfilled(initialValue) && sameDimCandidates.length >= 1;
      var chosenCandidate = sameDimCandidates[0];

      return (replaceFulfilledEntity ? filterIntersectingEntities(candidates, chosenCandidate) : candidates).filter(function (candidate) {
        return candidate.dim === dialogParameter.dim;
      }).reduce(function (_ref2, candidate) {
        var newValue = _ref2.newValue,
            remainingCandidates = _ref2.remainingCandidates;

        if (dialogParameter.isFulfilled(newValue)) {
          return { remainingCandidates: remainingCandidates, newValue: newValue };
        }
        var reducedValue = dialogParameter.reducer(newValue, candidate);
        return {
          remainingCandidates: filterIntersectingEntities(remainingCandidates, candidate),
          newValue: reducedValue === undefined ? null : reducedValue
        };
      }, {
        remainingCandidates: replaceFulfilledEntity ? filterIntersectingEntities(candidates, chosenCandidate) : candidates,
        newValue: replaceFulfilledEntity ? getEntityInitialValue(initialValue)(chosenCandidate) : initialValue
      });
    }

    /**
     * Computes matched and missing entities.
     * @param {Array.<Object[]>} candidates - array of raw entities given by the extractor.
     * They are candidates for the entity parameters
     * @param {Object} parameters - map of entities expected by the dialog: {
     *   <entityName>: {
     *     dim: String,
     *     priority: Number,
     *     isFulfilled: Function()
     *     reducer: Function(),
     *   }
     * }
     * @param {Object} dialogEntities - a map of the entities already matched for this dialog: {
     *   <entityName>: <messageEntity>
     * }
     * @returns {Object} object containing missingEntities and matchedEntities
     * (same structure as dialogEntities)
     */

  }, {
    key: 'computeEntities',
    value: function computeEntities(candidates, parameters) {
      var _this2 = this;

      var dialogEntities = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      logger.debug('computeEntities', { candidates: candidates, parameters: parameters, dialogEntities: dialogEntities });
      // Setup default values for entities
      var dialogParameters = Object.keys(parameters).reduce(function (allEntities, name) {
        var dialogParameter = parameters[name];
        return _extends({}, allEntities, _defineProperty({}, name, {
          dim: dialogParameter.dim,
          // If the reducer function is not defined,
          // we replace the old entities by the new ones
          reducer: dialogParameter.reducer || function (oldEntities, newEntities) {
            return newEntities;
          },
          // If the isFulfilled function is not defined,
          // we check that the entity is not null and not undefined
          isFulfilled: dialogParameter.isFulfilled || function (entity) {
            return entity != null;
          },
          // Because we need to to be able to override them but we want unfulfilled parameters
          // to have priority over them
          priority: dialogParameter.priority || 0
        }));
      }, {});
      var result = Object.keys(dialogParameters)
      // Sort expected entities by:
      // - isFulfilled descending (unfulfilled first)
      // - then priority descending (highest priority first)
      .sort(function (nameA, nameB) {
        var dialogParameterA = dialogParameters[nameA];
        var dialogParameterB = dialogParameters[nameB];
        var priorityA = dialogParameterA.priority;
        var priorityB = dialogParameterB.priority;
        var isFulfilledA = dialogParameterA.isFulfilled(dialogEntities[nameA], { dialogEntities: dialogEntities }) ? 0 : 1;
        var isFulfilledB = dialogParameterB.isFulfilled(dialogEntities[nameB], { dialogEntities: dialogEntities }) ? 0 : 1;
        if (isFulfilledB !== isFulfilledA) {
          return isFulfilledB - isFulfilledA;
        }
        return priorityB - priorityA;
      }).reduce(function (_ref3, name) {
        var matchedEntities = _ref3.matchedEntities,
            remainingCandidates = _ref3.remainingCandidates,
            missingEntities = _ref3.missingEntities;

        var dialogParameter = dialogParameters[name];

        var _matchParameterWithCa = _this2.matchParameterWithCandidates({
          dialogParameter: dialogParameter,
          candidates: remainingCandidates,
          initialValue: dialogEntities[name]
        }),
            newValue = _matchParameterWithCa.newValue,
            newRemainingCandidates = _matchParameterWithCa.remainingCandidates;

        logger.debug('computeEntities: after matchParameterWithCandidates', {
          newValue: newValue,
          remainingCandidates: remainingCandidates
        });
        var isFulfilled = dialogParameter.isFulfilled(newValue, { dialogEntities: dialogEntities });
        return {
          // Store the found entities here as a { <entityName>: <entity> } map
          matchedEntities: _extends({}, matchedEntities, _defineProperty({}, name, newValue)),
          remainingCandidates: newRemainingCandidates,
          // If an entity matching the one we are expecting was found,
          // remove it from missing entities
          // If it was not found, keep missing entities intact
          missingEntities: isFulfilled ? omit(missingEntities, [name]) : missingEntities
        };
      }, {
        matchedEntities: dialogEntities,
        remainingCandidates: candidates,
        missingEntities: dialogParameters
      });
      return { matchedEntities: result.matchedEntities, missingEntities: result.missingEntities };
    }

    /**
     * Executes the dialog.
     * @async
     * @param {Adapter} adapter - the adapter
     * @param {Object} userMessage - the user message
     * @param {Object[]} candidates - the message entities extracted from the message
     * @returns {Promise.<Object>} an action
     */

  }, {
    key: 'execute',
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(adapter, userMessage, candidates) {
        var userId, dialogEntities, _computeEntities, missingEntities, matchedEntities, dialogData, result;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                logger.debug('execute', userMessage, candidates);
                userId = userMessage.user;
                _context.next = 4;
                return this.brain.conversationGet(userId, this.parameters.namespace);

              case 4:
                _context.t0 = _context.sent;

                if (_context.t0) {
                  _context.next = 7;
                  break;
                }

                _context.t0 = {};

              case 7:
                dialogEntities = _context.t0;

                logger.debug('execute: dialogEntities', dialogEntities);
                // Get missing entities and matched entities
                _computeEntities = this.computeEntities(candidates, this.parameters.entities, dialogEntities), missingEntities = _computeEntities.missingEntities, matchedEntities = _computeEntities.matchedEntities;

                logger.debug('execute', { missingEntities: missingEntities, matchedEntities: matchedEntities });
                _context.next = 13;
                return this.brain.conversationSet(userId, this.parameters.namespace, matchedEntities);

              case 13:
                _context.next = 15;
                return this.dialogWillDisplay(userMessage, {
                  missingEntities: missingEntities,
                  matchedEntities: matchedEntities
                });

              case 15:
                dialogData = _context.sent;
                _context.next = 18;
                return this.display(adapter, userMessage, { matchedEntities: matchedEntities, missingEntities: missingEntities, dialogData: dialogData });

              case 18:
                if (!(Object.keys(missingEntities).length === 0)) {
                  _context.next = 23;
                  break;
                }

                _context.next = 21;
                return this.dialogWillComplete(userMessage, {
                  matchedEntities: matchedEntities,
                  missingEntities: missingEntities
                });

              case 21:
                result = _context.sent;
                return _context.abrupt('return', result || this.complete());

              case 23:
                return _context.abrupt('return', this.wait());

              case 24:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function execute(_x2, _x3, _x4) {
        return _ref4.apply(this, arguments);
      }

      return execute;
    }()
  }]);

  return PromptDialog;
}(Dialog);

module.exports = PromptDialog;