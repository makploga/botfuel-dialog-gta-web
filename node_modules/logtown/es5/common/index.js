'use strict';

var EmptyObject = require('ember-empty-object');
var lget = require('lodash.get');
var lmerge = require('lodash.merge');
var lset = require('lodash.set');
var lomit = require('lodash.omit');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var loggers = new EmptyObject();
var configs = new EmptyObject();
var wrappers = [];
var plugins = [];
var LEVELS = Object.freeze({ SILLY: 'SILLY', DEBUG: 'DEBUG', INFO: 'INFO', WARN: 'WARN', ERROR: 'ERROR' });

function cloneFast(obj) {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Send log message to all available wrappers
 *
 * @param {string} id
 * @param {string} level
 * @param {boolean} fallbackToLog
 * @param {[]} rest
 */
function sendMessage(id, level, fallbackToLog) {
  var options = lmerge({}, lget(configs, 'namespaces.' + id, {}), { disable: lget(configs, 'disable', []) }, lomit(configs, ['namespaces', 'disable']), { disable: configs.useGlobal ? lget(global, 'logtown.namespaces.' + id + '.disable', []) : [] });
  options.disable = options.disable.map(function (d) {
    return d.toUpperCase();
  });
  var tagsToDisable = lget(configs, 'tags.disable', []);
  var namespaceTags = lget(configs, 'namespaces.' + id + '.tags', []);
  var containsDisabledTag = tagsToDisable.some(function (element) {
    return namespaceTags.indexOf(element) > -1;
  });

  var stats = calcStats();
  var levelMethod = level.toLowerCase();

  for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    rest[_key - 3] = arguments[_key];
  }

  var logArgs = applyPlugins.apply(undefined, [id, level, stats].concat(rest));
  if (logArgs.length === 0) {
    logArgs = [id, level, stats].concat(rest);
  }

  var logArgsWithoutLevel = cloneFast(logArgs);
  logArgsWithoutLevel.splice(1, 1);

  if (options.disable.indexOf(level) > -1 || containsDisabledTag) {
    return;
  }

  wrappers.concat(options.wrappers).forEach(function (wrapper) {
    if (typeof wrapper[levelMethod] === 'function') {
      return wrapper[levelMethod].apply(wrapper, _toConsumableArray(logArgsWithoutLevel));
    } else if (typeof wrapper.log === 'function' && !!fallbackToLog) {
      return wrapper.log.apply(wrapper, _toConsumableArray(logArgs));
    }
  });
}

/**
 * Prepare stats. Currently only maxIdLength supported
 *
 * @return {{maxIdLength: number}}
 */
function calcStats() {
  return {
    maxIdLength: Math.max.apply(Math, _toConsumableArray(Object.keys(loggers).map(function (l) {
      return l.length;
    })))
  };
}

/**
 * @param {string} id
 * @param {string} level
 * @param {{}} stats
 * @param {*} rest
 * @return {[]}
 */
function applyPlugins(id, level, stats) {
  for (var _len2 = arguments.length, rest = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    rest[_key2 - 3] = arguments[_key2];
  }

  return plugins.reduce(function (acc, pluginFn) {
    if (!Array.isArray(acc)) {
      throw new Error('Plugin must return array');
    }
    if (acc.length === 0) {
      console.warn('Possible error. Some of the plugins returned empty array.');
    }
    return pluginFn.apply(undefined, _toConsumableArray(acc));
  }, [id, level, stats].concat(rest));
}

/**
 * Create new logger instance
 *
 * @param {string} id
 * @return {{id, silly: (function(...[*])), debug: (function(...[*])), info: (function(...[*])), warn: (function(...[*])), error: (function(...[*]))}}
 */
function createLogger(id) {
  var log = function log(level, fallbackToLog) {
    for (var _len3 = arguments.length, rest = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      rest[_key3 - 2] = arguments[_key3];
    }

    return sendMessage.apply(undefined, [id, level, fallbackToLog].concat(rest));
  };
  return {
    get id() {
      return id;
    },
    silly: function silly() {
      for (var _len4 = arguments.length, rest = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        rest[_key4] = arguments[_key4];
      }

      log.apply(undefined, [LEVELS.SILLY, true].concat(rest));
    },
    debug: function debug() {
      for (var _len5 = arguments.length, rest = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        rest[_key5] = arguments[_key5];
      }

      log.apply(undefined, [LEVELS.DEBUG, true].concat(rest));
    },
    info: function info() {
      for (var _len6 = arguments.length, rest = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        rest[_key6] = arguments[_key6];
      }

      log.apply(undefined, [LEVELS.INFO, true].concat(rest));
    },
    warn: function warn() {
      for (var _len7 = arguments.length, rest = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        rest[_key7] = arguments[_key7];
      }

      log.apply(undefined, [LEVELS.WARN, true].concat(rest));
    },
    error: function error() {
      for (var _len8 = arguments.length, rest = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        rest[_key8] = arguments[_key8];
      }

      log.apply(undefined, [LEVELS.ERROR, true].concat(rest));
    },

    // CAUTION: experimental feature
    send: function send(level) {
      for (var _len9 = arguments.length, rest = Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
        rest[_key9 - 1] = arguments[_key9];
      }

      log.apply(undefined, [level, false].concat(rest));
    }
  };
}

/**
 * Returns array if not array is passed to the function
 *
 * @param {[]|any} value
 * @return {[]}
 */
function normalizeArray() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (Array.isArray(value)) {
    return value;
  }
  return [value];
}

/**
 * Get logger that exits or create new one
 *
 * @param {String} id
 * @param {[]} disable
 * @param {[]} wrappers
 * @param {[]} tags
 * @returns {{silly: Function, debug: Function, info: Function, warn: Function, error: Function}}
 */
function getLogger(id) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$disable = _ref.disable,
      disable = _ref$disable === undefined ? [] : _ref$disable,
      _ref$wrappers = _ref.wrappers,
      wrappers = _ref$wrappers === undefined ? [] : _ref$wrappers,
      _ref$tags = _ref.tags,
      tags = _ref$tags === undefined ? [] : _ref$tags;

  var config = {
    disable: normalizeArray(disable).map(function (v) {
      return v + '';
    }),
    wrappers: normalizeArray(wrappers),
    tags: normalizeArray(tags)
  };

  lset(configs, 'namespaces.' + id, lmerge(lget(configs, 'namespaces.' + id, {}), config));

  return loggers[id] || (loggers[id] = createLogger(id));
}

/**
 * Add global configs
 *
 * @param {boolean} useGlobal
 * @param {[]} disable
 * @param {{}} namespaces
 * @param {{}} tags
 */
function configure() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$useGlobal = _ref2.useGlobal,
      useGlobal = _ref2$useGlobal === undefined ? true : _ref2$useGlobal,
      _ref2$disable = _ref2.disable,
      disable = _ref2$disable === undefined ? [] : _ref2$disable,
      _ref2$namespaces = _ref2.namespaces,
      namespaces = _ref2$namespaces === undefined ? {} : _ref2$namespaces,
      _ref2$tags = _ref2.tags,
      tags = _ref2$tags === undefined ? {} : _ref2$tags;

  var config = {
    useGlobal: !!useGlobal,
    disable: normalizeArray(disable).map(function (v) {
      return v + '';
    }),
    namespaces: namespaces,
    tags: { disable: normalizeArray(lget(tags, 'disable', [])) }
  };
  lmerge(configs, config);
}

/**
 * Add new wrapper. Can handle any object with one of methods from array:
 * ['log', 'silly', 'debug', 'info', 'warn', 'error']
 *
 * @param {{log?: Function, silly?: Function, debug?: Function, info?: Function, warn?: Function, error?: Function}|Function} wrapper
 */
function addWrapper(wrapper) {
  if (typeof wrapper.log === 'function' || Object.keys(LEVELS).some(function (level) {
    return typeof wrapper[level.toLowerCase()] === 'function';
  })) {
    wrappers.push(wrapper);
    return;
  }
  if (typeof wrapper === 'function') {
    wrappers.push({ log: wrapper });
    return;
  }
  throw new Error('Wrapper did not implemented a minimum methods required');
}

/**
 * Add plugin function. Plugin function must return array with log argument values.
 */
function addPlugin(useLevel, fn) {
  var pluginFn = fn;
  if (typeof fn === 'undefined' && typeof useLevel === 'function') {
    pluginFn = useLevel;
  }

  if (typeof pluginFn !== 'function') {
    throw new Error('Plugin must be a function!');
  }

  if (typeof useLevel === 'string') {
    pluginFn = function pluginFn(id, level, stats) {
      for (var _len10 = arguments.length, rest = Array(_len10 > 3 ? _len10 - 3 : 0), _key10 = 3; _key10 < _len10; _key10++) {
        rest[_key10 - 3] = arguments[_key10];
      }

      if (level === useLevel.toUpperCase()) {
        return fn.apply(undefined, [id, level, stats].concat(rest));
      }
      return [id, level, stats].concat(rest);
    };
  }

  plugins.push(pluginFn);
}

/**
 * The method is intended to be used during testing. Should not be used.
 */
function clean() {
  wrappers.splice(0, wrappers.length);
  plugins.splice(0, plugins.length);
}

/**
 * Factory method which returns logger. alias to getLogger()
 *
 * @param {String} id
 * @param {[]} disable
 * @param {[]} wrappers
 * @returns {{silly: Function, debug: Function, info: Function, warn: Function, error: Function}}
 */
var factory = function factory() {
  return getLogger.apply(undefined, arguments);
};

factory.getLogger = getLogger;
factory.configure = configure;
factory.addWrapper = addWrapper;
factory.addPlugin = addPlugin;
factory.LEVELS = LEVELS;
factory.clean = clean;

module.exports = factory;
